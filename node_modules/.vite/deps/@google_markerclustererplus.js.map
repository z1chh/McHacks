{
  "version": 3,
  "sources": ["../../@google/markerclustererplus/src/overlay-view-safe.ts", "../../@google/markerclustererplus/src/cluster-icon.ts", "../../@google/markerclustererplus/src/cluster.ts", "../../@google/markerclustererplus/src/markerclusterer.ts", "../../@google/markerclustererplus/src/index.ts"],
  "sourcesContent": ["/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface OverlayViewSafe extends google.maps.OverlayView {}\n\n/**\n * Extends an object's prototype by another's.\n *\n * @param type1 The Type to be extended.\n * @param type2 The Type to extend with.\n * @ignore\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction extend(type1: any, type2: any): void {\n  // eslint-disable-next-line prefer-const\n  for (let property in type2.prototype) {\n    type1.prototype[property] = type2.prototype[property];\n  }\n}\n\n/**\n * @ignore\n */\nexport class OverlayViewSafe {\n  constructor() {\n    // MarkerClusterer implements google.maps.OverlayView interface. We use the\n    // extend function to extend MarkerClusterer with google.maps.OverlayView\n    // because it might not always be available when the code is defined so we\n    // look for it at the last possible moment. If it doesn't exist now then\n    // there is no point going ahead :)\n    extend(OverlayViewSafe, google.maps.OverlayView);\n  }\n}\n", "/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * This class represents the object for values in the `styles` array passed\n * to the {@link MarkerClusterer} constructor. The element in this array that is used to\n * style the cluster icon is determined by calling the `calculator` function.\n */\nimport { Cluster } from \"./cluster\";\nimport { OverlayViewSafe } from \"./overlay-view-safe\";\n\n/**\n *\n * @hidden\n */\nfunction toCssText(styles: { [key: string]: string }): string {\n  return Object.keys(styles)\n    .reduce((acc, key) => {\n      if (styles[key]) {\n        acc.push(key + \":\" + styles[key]);\n      }\n      return acc;\n    }, [])\n    .join(\";\");\n}\n\n/**\n *\n * @hidden\n */\nfunction coercePixels(pixels: number): string {\n  return pixels ? pixels + \"px\" : undefined;\n}\n\nexport interface ClusterIconStyle {\n  /** The URL of the cluster icon image file. If not set, img element will not be created */\n  url?: string;\n  /** The name of the CSS class defining styles for the cluster markers. */\n  className?: string;\n  /** Height The display height (in pixels) of the cluster icon. Required. */\n  height: number;\n  /** Width The display width (in pixels) of the cluster icon. Required. */\n  width: number;\n  /**\n   * The position (in pixels) from the center of the cluster icon to\n   * where the text label is to be centered and drawn. The format is `[yoffset, xoffset]`\n   * where `yoffset` increases as you go down from center and `xoffset`\n   * increases to the right of center. The default is `[0, 0]`.\n   */\n  anchorText?: [number, number];\n  /**\n   * The anchor position (in pixels) of the cluster icon. This is the\n   * spot on the cluster icon that is to be aligned with the cluster position. The format is\n   * `[yoffset, xoffset]` where `yoffset` increases as you go down and\n   * `xoffset` increases to the right of the top-left corner of the icon. The default\n   * anchor position is the center of the cluster icon.\n   */\n  anchorIcon?: [number, number];\n  /**\n   * The color of the label text shown on the cluster icon.\n   * @default `\"black\"`\n   */\n  textColor?: string;\n  /** The size (in pixels) of the label text shown on the cluster icon.\n   * @default `11`\n   */\n  textSize?: number;\n\n  /** The line height (in pixels) of the label text shown on the cluster icon.\n   * @default the same as cluster icon height\n   */\n  textLineHeight?: number;\n  /**\n   * The value of the CSS `text-decoration`\n   * property for the label text shown on the cluster icon.\n   *\n   * @default `\"none\"`\n   */\n  textDecoration?: string;\n  /**\n   * The value of the CSS `font-weight`\n   * property for the label text shown on the cluster icon.\n   *\n   *  @default `\"bold\"`\n   */\n  fontWeight?: string;\n  /**\n   *  The value of the CSS `font-style`\n   *  property for the label text shown on the cluster icon.\n   *\n   *  @default `\"normal\"`\n   */\n  fontStyle?: string;\n  /**\n   *  The value of the CSS `font-family`\n   *  property for the label text shown on the cluster icon.\n   *  @default `\"Arial,sans-serif\"`\n   */\n  fontFamily?: string;\n  /**\n   * The position of the cluster icon image\n   * within the image defined by `url`. The format is `\"xpos ypos\"`\n   * (the same format as for the CSS `background-position` property). You must set\n   * this property appropriately when the image defined by `url` represents a sprite\n   * containing multiple images. Note that the position <i>must</i> be specified in px units.\n   *\n   * @default `\"0 0\"`\n   */\n  backgroundPosition?: string;\n}\n\n/**\n * @description This is an object containing general information about a cluster icon. This is\n *  the object that a `calculator` function returns.\n */\nexport interface ClusterIconInfo {\n  /**\n   * The text of the label to be shown on the cluster icon.\n   */\n  text: string;\n  /**\n   * The index plus 1 of the element in the `styles`\n   */\n  index: number;\n  /**\n   * The tooltip to display when the mouse moves over the cluster icon.\n   * If this value is `undefined` or `\"\"`, `title` is set to the\n   * value of the `title` property passed to the MarkerClusterer.\n   */\n  title: string;\n}\n\n/**\n * A cluster icon.\n */\nexport class ClusterIcon extends OverlayViewSafe {\n  private className_: string;\n  private center_: google.maps.LatLng = null;\n  private div_: HTMLDivElement = null;\n  private sums_: ClusterIconInfo = null;\n  private visible_ = false;\n\n  private style: ClusterIconStyle = null;\n\n  private anchorText_: [number, number];\n  private anchorIcon_: [number, number];\n\n  private boundsChangedListener_: google.maps.MapsEventListener;\n\n  /**\n   * @param cluster_ The cluster with which the icon is to be associated.\n   * @param styles_ An array of {@link ClusterIconStyle} defining the cluster icons\n   *  to use for various cluster sizes.\n   */\n  constructor(private cluster_: Cluster, private styles_: ClusterIconStyle[]) {\n    super();\n\n    this.setMap(cluster_.getMap()); // Note: this causes onAdd to be called\n  }\n\n  /**\n   * Adds the icon to the DOM.\n   */\n  onAdd(): void {\n    let cMouseDownInCluster: boolean;\n    let cDraggingMapByCluster: boolean;\n\n    const mc = this.cluster_.getMarkerClusterer();\n\n    const [major, minor] = google.maps.version.split(\".\");\n\n    const gmVersion = parseInt(major, 10) * 100 + parseInt(minor, 10);\n\n    this.div_ = document.createElement(\"div\");\n    if (this.visible_) {\n      this.show();\n    }\n\n    this.getPanes().overlayMouseTarget.appendChild(this.div_);\n\n    // Fix for Issue 157\n    this.boundsChangedListener_ = google.maps.event.addListener(\n      this.getMap(),\n      \"bounds_changed\",\n      function() {\n        cDraggingMapByCluster = cMouseDownInCluster;\n      }\n    );\n\n    google.maps.event.addDomListener(this.div_, \"mousedown\", () => {\n      cMouseDownInCluster = true;\n      cDraggingMapByCluster = false;\n    });\n\n    // March 1, 2018: Fix for this 3.32 exp bug, https://issuetracker.google.com/issues/73571522\n    // But it doesn't work with earlier releases so do a version check.\n    if (gmVersion >= 332) {\n      // Ugly version-dependent code\n      google.maps.event.addDomListener(this.div_, \"touchstart\", e => {\n        e.stopPropagation();\n      });\n    }\n\n    google.maps.event.addDomListener(this.div_, \"click\", e => {\n      cMouseDownInCluster = false;\n      if (!cDraggingMapByCluster) {\n        /**\n         * This event is fired when a cluster marker is clicked.\n         * @name MarkerClusterer#click\n         * @param {Cluster} c The cluster that was clicked.\n         * @event\n         */\n        google.maps.event.trigger(mc, \"click\", this.cluster_);\n        google.maps.event.trigger(mc, \"clusterclick\", this.cluster_); // deprecated name\n\n        // The default click handler follows. Disable it by setting\n        // the zoomOnClick property to false.\n        if (mc.getZoomOnClick()) {\n          // Zoom into the cluster.\n          const mz = mc.getMaxZoom();\n          const theBounds = this.cluster_.getBounds();\n          (mc.getMap() as google.maps.Map).fitBounds(theBounds);\n          // There is a fix for Issue 170 here:\n          setTimeout(function() {\n            (mc.getMap() as google.maps.Map).fitBounds(theBounds);\n            // Don't zoom beyond the max zoom level\n            if (mz !== null && mc.getMap().getZoom() > mz) {\n              mc.getMap().setZoom(mz + 1);\n            }\n          }, 100);\n        }\n\n        // Prevent event propagation to the map:\n        e.cancelBubble = true;\n        if (e.stopPropagation) {\n          e.stopPropagation();\n        }\n      }\n    });\n\n    google.maps.event.addDomListener(this.div_, \"mouseover\", () => {\n      /**\n       * This event is fired when the mouse moves over a cluster marker.\n       * @name MarkerClusterer#mouseover\n       * @param {Cluster} c The cluster that the mouse moved over.\n       * @event\n       */\n      google.maps.event.trigger(mc, \"mouseover\", this.cluster_);\n    });\n\n    google.maps.event.addDomListener(this.div_, \"mouseout\", () => {\n      /**\n       * This event is fired when the mouse moves out of a cluster marker.\n       * @name MarkerClusterer#mouseout\n       * @param {Cluster} c The cluster that the mouse moved out of.\n       * @event\n       */\n      google.maps.event.trigger(mc, \"mouseout\", this.cluster_);\n    });\n  }\n\n  /**\n   * Removes the icon from the DOM.\n   */\n  onRemove(): void {\n    if (this.div_ && this.div_.parentNode) {\n      this.hide();\n      google.maps.event.removeListener(this.boundsChangedListener_);\n      google.maps.event.clearInstanceListeners(this.div_);\n      this.div_.parentNode.removeChild(this.div_);\n      this.div_ = null;\n    }\n  }\n\n  /**\n   * Draws the icon.\n   */\n  draw(): void {\n    if (this.visible_) {\n      const pos = this.getPosFromLatLng_(this.center_);\n      this.div_.style.top = pos.y + \"px\";\n      this.div_.style.left = pos.x + \"px\";\n    }\n  }\n\n  /**\n   * Hides the icon.\n   */\n  hide(): void {\n    if (this.div_) {\n      this.div_.style.display = \"none\";\n    }\n    this.visible_ = false;\n  }\n\n  /**\n   * Positions and shows the icon.\n   */\n  show(): void {\n    if (this.div_) {\n      this.div_.className = this.className_;\n      this.div_.style.cssText = this.createCss_(\n        this.getPosFromLatLng_(this.center_)\n      );\n\n      this.div_.innerHTML =\n        (this.style.url ? this.getImageElementHtml() : \"\") +\n        this.getLabelDivHtml();\n\n      if (typeof this.sums_.title === \"undefined\" || this.sums_.title === \"\") {\n        this.div_.title = this.cluster_.getMarkerClusterer().getTitle();\n      } else {\n        this.div_.title = this.sums_.title;\n      }\n      this.div_.style.display = \"\";\n    }\n    this.visible_ = true;\n  }\n\n  private getLabelDivHtml(): string {\n    const mc = this.cluster_.getMarkerClusterer();\n    const ariaLabel = mc.ariaLabelFn(this.sums_.text);\n\n    const divStyle: { [key: string]: string } = {\n      position: \"absolute\",\n      top: coercePixels(this.anchorText_[0]),\n      left: coercePixels(this.anchorText_[1]),\n      color: this.style.textColor,\n      \"font-size\": coercePixels(this.style.textSize),\n      \"font-family\": this.style.fontFamily,\n      \"font-weight\": this.style.fontWeight,\n      \"font-style\": this.style.fontStyle,\n      \"text-decoration\": this.style.textDecoration,\n      \"text-align\": \"center\",\n      width: coercePixels(this.style.width),\n      \"line-height\": coercePixels(this.style.textLineHeight)\n    };\n\n    return `\n<div aria-label=\"${ariaLabel}\" style=\"${toCssText(divStyle)}\" tabindex=\"0\">\n  <span aria-hidden=\"true\">${this.sums_.text}</span>\n</div>\n`;\n  }\n\n  private getImageElementHtml(): string {\n    // NOTE: values must be specified in px units\n    const bp = (this.style.backgroundPosition || \"0 0\").split(\" \");\n    const spriteH = parseInt(bp[0].replace(/^\\s+|\\s+$/g, \"\"), 10);\n    const spriteV = parseInt(bp[1].replace(/^\\s+|\\s+$/g, \"\"), 10);\n\n    let dimensions: { [key: string]: string } = {};\n\n    if (this.cluster_.getMarkerClusterer().getEnableRetinaIcons()) {\n      dimensions = {\n        width: coercePixels(this.style.width),\n        height: coercePixels(this.style.height)\n      };\n    } else {\n      const [Y1, X1, Y2, X2] = [\n        -1 * spriteV,\n        -1 * spriteH + this.style.width,\n        -1 * spriteV + this.style.height,\n        -1 * spriteH\n      ];\n      dimensions = {\n        clip: `rect(${Y1}px, ${X1}px, ${Y2}px, ${X2}px)`\n      };\n    }\n\n    const cssText = toCssText({\n      position: \"absolute\",\n      top: coercePixels(spriteV),\n      left: coercePixels(spriteH),\n      ...dimensions\n    });\n\n    return `<img alt=\"${this.sums_.text}\" aria-hidden=\"true\" src=\"${this.style.url}\" style=\"${cssText}\"/>`;\n  }\n\n  /**\n   * Sets the icon styles to the appropriate element in the styles array.\n   *\n   * @ignore\n   * @param sums The icon label text and styles index.\n   */\n  useStyle(sums: ClusterIconInfo): void {\n    this.sums_ = sums;\n    let index = Math.max(0, sums.index - 1);\n    index = Math.min(this.styles_.length - 1, index);\n    this.style = this.styles_[index];\n\n    this.anchorText_ = this.style.anchorText || [0, 0];\n    this.anchorIcon_ = this.style.anchorIcon || [\n      Math.floor(this.style.height / 2),\n      Math.floor(this.style.width / 2)\n    ];\n\n    this.className_ =\n      this.cluster_.getMarkerClusterer().getClusterClass() +\n      \" \" +\n      (this.style.className || \"cluster-\" + index);\n  }\n\n  /**\n   * Sets the position at which to center the icon.\n   *\n   * @param center The latlng to set as the center.\n   */\n  setCenter(center: google.maps.LatLng): void {\n    this.center_ = center;\n  }\n\n  /**\n   * Creates the `cssText` style parameter based on the position of the icon.\n   *\n   * @param pos The position of the icon.\n   * @return The CSS style text.\n   */\n  private createCss_(pos: google.maps.Point): string {\n    return toCssText({\n      \"z-index\": `${this.cluster_.getMarkerClusterer().getZIndex()}`,\n      top: coercePixels(pos.y),\n      left: coercePixels(pos.x),\n      width: coercePixels(this.style.width),\n      height: coercePixels(this.style.height),\n      cursor: \"pointer\",\n      position: \"absolute\",\n      \"-webkit-user-select\": \"none\",\n      \"-khtml-user-select\": \"none\",\n      \"-moz-user-select\": \"none\",\n      \"-o-user-select\": \"none\",\n      \"user-select\": \"none\"\n    });\n  }\n\n  /**\n   * Returns the position at which to place the DIV depending on the latlng.\n   *\n   * @param latlng The position in latlng.\n   * @return The position in pixels.\n   */\n  private getPosFromLatLng_(latlng: google.maps.LatLng): google.maps.Point {\n    const pos = this.getProjection().fromLatLngToDivPixel(latlng);\n    pos.x = Math.floor(pos.x - this.anchorIcon_[1]);\n    pos.y = Math.floor(pos.y - this.anchorIcon_[0]);\n    return pos;\n  }\n}\n", "/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { MarkerClusterer, ClusterAugmentedMarker } from \"./markerclusterer\";\nimport { ClusterIcon } from \"./cluster-icon\";\n\n/**\n * Creates a single cluster that manages a group of proximate markers.\n *  Used internally, do not call this constructor directly.\n */\nexport class Cluster {\n  private map_ = this.markerClusterer_.getMap() as google.maps.Map;\n  private minClusterSize_: number = this.markerClusterer_.getMinimumClusterSize();\n  private averageCenter_: boolean = this.markerClusterer_.getAverageCenter();\n  private markers_: ClusterAugmentedMarker[] = []; // TODO: type;\n  private center_: google.maps.LatLng = null;\n  private bounds_: google.maps.LatLngBounds = null;\n  private clusterIcon_ = new ClusterIcon(\n    this,\n    this.markerClusterer_.getStyles()\n  );\n\n  /**\n   *\n   * @param markerClusterer_ The `MarkerClusterer` object with which this\n   *  cluster is associated.\n   */\n  constructor(private markerClusterer_: MarkerClusterer) {}\n\n  /**\n   * Returns the number of markers managed by the cluster. You can call this from\n   * a `click`, `mouseover`, or `mouseout` event handler for the `MarkerClusterer` object.\n   *\n   * @return The number of markers in the cluster.\n   */\n  public getSize(): number {\n    return this.markers_.length;\n  }\n\n  /**\n   * Returns the array of markers managed by the cluster. You can call this from\n   * a `click`, `mouseover`, or `mouseout` event handler for the `MarkerClusterer` object.\n   *\n   * @return The array of markers in the cluster.\n   */\n  public getMarkers(): google.maps.Marker[] {\n    return this.markers_;\n  }\n\n  /**\n   * Returns the center of the cluster. You can call this from\n   * a `click`, `mouseover`, or `mouseout` event handler\n   * for the `MarkerClusterer` object.\n   *\n   * @return The center of the cluster.\n   */\n  public getCenter(): google.maps.LatLng {\n    return this.center_;\n  }\n\n  /**\n   * Returns the map with which the cluster is associated.\n   *\n   * @return The map.\n   * @ignore\n   */\n  public getMap(): google.maps.Map {\n    return this.map_;\n  }\n\n  /**\n   * Returns the `MarkerClusterer` object with which the cluster is associated.\n   *\n   * @return The associated marker clusterer.\n   * @ignore\n   */\n  public getMarkerClusterer(): MarkerClusterer {\n    return this.markerClusterer_;\n  }\n\n  /**\n   * Returns the bounds of the cluster.\n   *\n   * @return the cluster bounds.\n   * @ignore\n   */\n  public getBounds(): google.maps.LatLngBounds {\n    const bounds = new google.maps.LatLngBounds(this.center_, this.center_);\n    const markers = this.getMarkers();\n    for (let i = 0; i < markers.length; i++) {\n      bounds.extend(markers[i].getPosition());\n    }\n    return bounds;\n  }\n\n  /**\n   * Removes the cluster from the map.\n   *\n   * @ignore\n   */\n  public remove(): void {\n    this.clusterIcon_.setMap(null);\n    this.markers_ = [];\n    delete this.markers_;\n  }\n\n  /**\n   * Adds a marker to the cluster.\n   *\n   * @param marker The marker to be added.\n   * @return True if the marker was added.\n   * @ignore\n   */\n  public addMarker(\n    marker: google.maps.Marker & { isAdded?: boolean }\n  ): boolean {\n    if (this.isMarkerAlreadyAdded_(marker)) {\n      return false;\n    }\n\n    if (!this.center_) {\n      this.center_ = marker.getPosition();\n      this.calculateBounds_();\n    } else {\n      if (this.averageCenter_) {\n        const l = this.markers_.length + 1;\n        const lat =\n          (this.center_.lat() * (l - 1) + marker.getPosition().lat()) / l;\n        const lng =\n          (this.center_.lng() * (l - 1) + marker.getPosition().lng()) / l;\n        this.center_ = new google.maps.LatLng(lat, lng);\n        this.calculateBounds_();\n      }\n    }\n\n    marker.isAdded = true;\n    this.markers_.push(marker);\n\n    const mCount = this.markers_.length;\n    const mz = this.markerClusterer_.getMaxZoom();\n    if (mz !== null && this.map_.getZoom() > mz) {\n      // Zoomed in past max zoom, so show the marker.\n      if (marker.getMap() !== this.map_) {\n        marker.setMap(this.map_);\n      }\n    } else if (mCount < this.minClusterSize_) {\n      // Min cluster size not reached so show the marker.\n      if (marker.getMap() !== this.map_) {\n        marker.setMap(this.map_);\n      }\n    } else if (mCount === this.minClusterSize_) {\n      // Hide the markers that were showing.\n      for (let i = 0; i < mCount; i++) {\n        this.markers_[i].setMap(null);\n      }\n    } else {\n      marker.setMap(null);\n    }\n\n    return true;\n  }\n\n  /**\n   * Determines if a marker lies within the cluster's bounds.\n   *\n   * @param marker The marker to check.\n   * @return True if the marker lies in the bounds.\n   * @ignore\n   */\n  public isMarkerInClusterBounds(marker: google.maps.Marker): boolean {\n    return this.bounds_.contains(marker.getPosition());\n  }\n\n  /**\n   * Calculates the extended bounds of the cluster with the grid.\n   */\n  private calculateBounds_(): void {\n    const bounds = new google.maps.LatLngBounds(this.center_, this.center_);\n    this.bounds_ = this.markerClusterer_.getExtendedBounds(bounds);\n  }\n\n  /**\n   * Updates the cluster icon.\n   */\n  public updateIcon(): void {\n    const mCount = this.markers_.length;\n    const mz = this.markerClusterer_.getMaxZoom();\n\n    if (mz !== null && this.map_.getZoom() > mz) {\n      this.clusterIcon_.hide();\n      return;\n    }\n\n    if (mCount < this.minClusterSize_) {\n      // Min cluster size not yet reached.\n      this.clusterIcon_.hide();\n      return;\n    }\n\n    const numStyles = this.markerClusterer_.getStyles().length;\n    const sums = this.markerClusterer_.getCalculator()(\n      this.markers_,\n      numStyles\n    );\n    this.clusterIcon_.setCenter(this.center_);\n    this.clusterIcon_.useStyle(sums);\n    this.clusterIcon_.show();\n  }\n\n  /**\n   * Determines if a marker has already been added to the cluster.\n   *\n   * @param marker The marker to check.\n   * @return True if the marker has already been added.\n   */\n  private isMarkerAlreadyAdded_(marker: google.maps.Marker): boolean {\n    if (this.markers_.indexOf) {\n      return this.markers_.indexOf(marker) !== -1;\n    } else {\n      for (let i = 0; i < this.markers_.length; i++) {\n        if (marker === this.markers_[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n}\n", "/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @name MarkerClustererPlus for Google Maps V3\n * @author Gary Little\n * @fileoverview\n * The library creates and manages per-zoom-level clusters for large amounts of markers.\n * <p>\n * This is an enhanced V3 implementation of the V2 MarkerClusterer by Xiaoxi Wu. It is\n * based on the V3 MarkerClusterer port by Luke Mahe. MarkerClustererPlus was created\n * by Gary Little.\n * <p>\n * v2.0 release: MarkerClustererPlus v2.0 is backward compatible with MarkerClusterer v1.0. It\n *  adds support for the `ignoreHidden`, `title`, `batchSizeIE`,\n *  and `calculator` properties as well as support for four more events. It also allows\n *  greater control over the styling of the text that appears on the cluster marker. The\n *  documentation has been significantly improved and the overall code has been simplified and\n *  polished. Very large numbers of markers can now be managed without causing Javascript timeout\n *  errors on Internet Explorer. Note that the name of the `clusterclick` event has been\n *  deprecated. The new name is `click`, so please change your application code now.\n */\n\nimport { ClusterIconInfo, ClusterIconStyle } from \"./cluster-icon\";\n\nimport { Cluster } from \"./cluster\";\nimport { OverlayViewSafe } from \"./overlay-view-safe\";\n\n/**\n * @param text The text attribute of the cluster\n */\ntype AriaLabelFn = (text: string) => string;\n\nexport type Calculator = (\n  markers: google.maps.Marker[],\n  clusterIconStylesCount: number\n) => ClusterIconInfo;\n\nexport interface ClusterAugmentedMarker extends google.maps.Marker {\n  isAdded?: boolean;\n}\n\n/**\n * This event is fired on the {@link MarkerClusterer} instance when the `MarkerClusterer` stops clustering markers.\n *\n * Example:\n * ```typescript\n *  mc.addListener('clusteringend', (mc: MarkerClusterer) => {})\n * ```\n *\n * @param mc The MarkerClusterer whose markers are being clustered.\n * @event clusteringend\n */\nexport declare function clusteringend(mc: MarkerClusterer): void;\n\n/**\n * This event is fired on the {@link MarkerClusterer} instance when the `MarkerClusterer` begins clustering markers.\n *\n * Example:\n * ```typescript\n *  mc.addListener('clusteringbegin', (mc: MarkerClusterer) => {})\n * ```\n *\n * @param mc The MarkerClusterer whose markers are being clustered.\n * @event clusteringbegin\n */\nexport declare function clusteringbegin(mc: MarkerClusterer): void;\n\n/**\n * Optional parameter passed to the {@link MarkerClusterer} constructor.\n */\nexport interface MarkerClustererOptions {\n  /**\n   * The grid size of a cluster in pixels. The grid is a square.\n   *\n   * @default `60`\n   */\n  gridSize?: number;\n  /**\n   * The maximum zoom level at which clustering is enabled or\n   * `null` if clustering is to be enabled at all zoom levels.\n   *\n   * @default `null`\n   */\n  maxZoom?: number;\n\n  /**\n   * Whether to zoom the map when a cluster marker is\n   * clicked. You may want to set this to `false` if you have installed a handler\n   * for the `click` event and it deals with zooming on its own.\n   *\n   * @default `true`\n   */\n  zoomOnClick?: boolean;\n  /***\n   * Whether the position of a cluster marker should be\n   * the average position of all markers in the cluster. If set to `false`, the\n   * cluster marker is positioned at the location of the first marker added to the cluster.\n   *\n   * @default `false`\n   */\n  averageCenter?: boolean;\n  /**\n   * The minimum number of markers needed in a cluster\n   * before the markers are hidden and a cluster marker appears.\n   *\n   * @default `2`\n   */\n  minimumClusterSize?: number;\n\n  /**\n   *  the z-index of a cluster.\n   *\n   *  @default `google.maps.Marker.MAX_ZINDEX + 1`\n   */\n  zIndex?: number;\n\n  /**\n   * Whether to ignore hidden markers in clusters. You\n   * may want to set this to `true` to ensure that hidden markers are not included\n   * in the marker count that appears on a cluster marker (this count is the value of the\n   * `text` property of the result returned by the default  {@link calculator}).\n   * If set to `true` and you change the visibility of a marker being clustered, be\n   * sure to also call {@link MarkerClusterer#repaint()}.\n   *\n   * @default `false`\n   */\n  ignoreHidden?: boolean;\n  /**\n   * The tooltip to display when the mouse moves over a cluster\n   * marker. (Alternatively, you can use a custom `calculator` function to specify a\n   * different tooltip for each cluster marker.)\n   *\n   * @default `\"\"`\n   */\n  title?: string;\n  /**\n   * The function used to determine\n   * the text to be displayed on a cluster marker and the index indicating which style to use\n   * for the cluster marker. The input parameters for the function are (1) the array of markers\n   * represented by a cluster marker and (2) the number of cluster icon styles. It returns a\n   * {@link ClusterIconInfo} object. The default `calculator` returns a\n   * `text` property which is the number of markers in the cluster and an\n   * `index` property which is one higher than the lowest integer such that\n   * `10^i` exceeds the number of markers in the cluster, or the size of the styles\n   * array, whichever is less. The `styles` array element used has an index of\n   * `index` minus 1. For example, the default `calculator` returns a\n   * `text` value of `\"125\"` and an `index` of `3`\n   * for a cluster icon representing 125 markers so the element used in the `styles`\n   * array is `2`. A `calculator` may also return a `title`\n   * property that contains the text of the tooltip to be used for the cluster marker. If\n   * `title` is not defined, the tooltip is set to the value of the `title`\n   * property for the MarkerClusterer.\n   *\n   * @default {@link MarkerClusterer.CALCULATOR}\n   */\n  calculator?: Calculator;\n  /**\n   * The name of the CSS class defining general styles\n   * for the cluster markers. Use this class to define CSS styles that are not set up by the code\n   * that processes the `styles` array.\n   *\n   * @default `\"cluster\"`\n   */\n  clusterClass?: string;\n  /**\n   * An array of {@link ClusterIconStyle} elements defining the styles\n   * of the cluster markers to be used. The element to be used to style a given cluster marker\n   * is determined by the function defined by the `calculator` property.\n   * The default is an array of {@link ClusterIconStyle} elements whose properties are derived\n   * from the values for `imagePath`, `imageExtension`, and `imageSizes`.\n   *\n   * @default `styles`\n   */\n  styles?: ClusterIconStyle[];\n  /**\n   * Whether to allow the use of cluster icons that\n   * have sizes that are some multiple (typically double) of their actual display size. Icons such\n   * as these look better when viewed on high-resolution monitors such as Apple's Retina displays.\n   * Note: if this property is `true`, sprites cannot be used as cluster icons.\n   *\n   * @default `false`\n   */\n  enableRetinaIcons?: boolean;\n  /**\n   * Set this property to the number of markers to be processed in a single batch when using\n   * a browser other than Internet Explorer (for Internet Explorer, use the batchSizeIE property instead).\n   *\n   * @default `MarkerClusterer.BATCH_SIZE`\n   */\n  batchSize?: number;\n  /**\n   * When Internet Explorer is\n   * being used, markers are processed in several batches with a small delay inserted between\n   * each batch in an attempt to avoid Javascript timeout errors. Set this property to the\n   * number of markers to be processed in a single batch; select as high a number as you can\n   * without causing a timeout error in the browser. This number might need to be as low as 100\n   * if 15,000 markers are being managed, for example.\n   *\n   * @default `MarkerClusterer.BATCH_SIZE_IE`\n   */\n  batchSizeIE?: number;\n  /**\n   * The full URL of the root name of the group of image files to use for cluster icons.\n   * The complete file name is of the form `imagePath`n.`imageExtension`\n   * where n is the image file number (1, 2, etc.).\n   *\n   * @default `MarkerClusterer.IMAGE_PATH`\n   */\n  imagePath?: string;\n  /**\n   * The extension name for the cluster icon image files (e.g., `\"png\"` or\n   * `\"jpg\"`).\n   *\n   * @default `MarkerClusterer.IMAGE_EXTENSION`\n   */\n  imageExtension?: string;\n  /**\n   * An array of numbers containing the widths of the group of\n   * `imagePath`n.`imageExtension` image files.\n   * (The images are assumed to be square.)\n   *\n   * @default `MarkerClusterer.IMAGE_SIZES`\n   */\n  imageSizes?: number[];\n  /**\n   * A function to take the text attribute associated with the cluster and output a string to attach an\n   * ariaLabel to the cluster\n   */\n  ariaLabelFn?: AriaLabelFn;\n}\n\n/**\n * @ignore\n */\nconst getOption = <T, K extends keyof T>(\n  options: T,\n  prop: K,\n  def: T[K]\n): T[K] => {\n  if (options[prop] !== undefined) {\n    return options[prop];\n  } else {\n    return def;\n  }\n};\n\nexport class MarkerClusterer extends OverlayViewSafe {\n  /**\n   * The number of markers to process in one batch.\n   */\n  static BATCH_SIZE = 2000;\n\n  /**\n   * The number of markers to process in one batch (IE only).\n   */\n  static BATCH_SIZE_IE = 500;\n\n  /**\n   * The default root name for the marker cluster images.\n   */\n  static IMAGE_PATH = \"../images/m\";\n\n  /**\n   * The default extension name for the marker cluster images.\n   */\n  static IMAGE_EXTENSION = \"png\";\n\n  /**\n   * The default array of sizes for the marker cluster images.\n   */\n  static IMAGE_SIZES: number[] = [53, 56, 66, 78, 90];\n\n  private markers_: ClusterAugmentedMarker[] = [];\n  private clusters_: Cluster[] = [];\n  private listeners_: google.maps.MapsEventListener[] = [];\n\n  private activeMap_: google.maps.Map = null;\n  private ready_ = false;\n\n  public ariaLabelFn = this.options.ariaLabelFn || ((): string => \"\");\n\n  private zIndex_ = this.options.zIndex || google.maps.Marker.MAX_ZINDEX + 1;\n  private gridSize_ = this.options.gridSize || 60;\n  private minClusterSize_ = this.options.minimumClusterSize || 2;\n  private maxZoom_ = this.options.maxZoom || null;\n  private styles_: ClusterIconStyle[] = this.options.styles || [];\n  private title_ = this.options.title || \"\";\n\n  private zoomOnClick_ = getOption(this.options, \"zoomOnClick\", true);\n  private averageCenter_ = getOption(this.options, \"averageCenter\", false);\n\n  private ignoreHidden_ = getOption(this.options, \"ignoreHidden\", false);\n  private enableRetinaIcons_ = getOption(\n    this.options,\n    \"enableRetinaIcons\",\n    false\n  );\n\n  private imagePath_ = this.options.imagePath || MarkerClusterer.IMAGE_PATH;\n  private imageExtension_ =\n    this.options.imageExtension || MarkerClusterer.IMAGE_EXTENSION;\n  private imageSizes_ = this.options.imageSizes || MarkerClusterer.IMAGE_SIZES;\n  private calculator_ = this.options.calculator || MarkerClusterer.CALCULATOR;\n  private batchSize_ = this.options.batchSize || MarkerClusterer.BATCH_SIZE;\n  private batchSizeIE_ =\n    this.options.batchSizeIE || MarkerClusterer.BATCH_SIZE_IE;\n  private clusterClass_ = this.options.clusterClass || \"cluster\";\n\n  private prevZoom_: number;\n  private timerRefStatic: number;\n\n  /**\n   * Creates a MarkerClusterer object with the options specified in {@link MarkerClustererOptions}.\n   * @param map The Google map to attach to.\n   * @param markers The markers to be added to the cluster.\n   * @param options The optional parameters.\n   */\n  constructor(\n    map: google.maps.Map,\n    markers: google.maps.Marker[] = [],\n    private options: MarkerClustererOptions = {}\n  ) {\n    super();\n\n    if (navigator.userAgent.toLowerCase().indexOf(\"msie\") !== -1) {\n      // Try to avoid IE timeout when processing a huge number of markers:\n      this.batchSize_ = this.batchSizeIE_;\n    }\n\n    this.setupStyles_();\n\n    this.addMarkers(markers, true);\n    this.setMap(map); // Note: this causes onAdd to be called\n  }\n\n  /**\n   * Implementation of the onAdd interface method.\n   * @ignore\n   */\n  onAdd(): void {\n    this.activeMap_ = this.getMap() as google.maps.Map;\n    this.ready_ = true;\n\n    this.repaint();\n\n    this.prevZoom_ = this.getMap().getZoom();\n\n    // Add the map event listeners\n    this.listeners_ = [\n      google.maps.event.addListener(this.getMap(), \"zoom_changed\", () => {\n        const map: google.maps.Map & {\n          minZoom: number;\n          maxZoom: number;\n          mapTypes: { [type: string]: google.maps.MapType };\n        } = this.getMap() as any; // eslint-disable-line @typescript-eslint/no-explicit-any\n\n        // Fix for bug #407\n        // Determines map type and prevents illegal zoom levels\n        const minZoom = map.minZoom || 0;\n        const maxZoom = Math.min(\n          map.maxZoom || 100,\n          map.mapTypes[map.getMapTypeId()].maxZoom\n        );\n        const zoom = Math.min(\n          Math.max(this.getMap().getZoom(), minZoom),\n          maxZoom\n        );\n\n        if (this.prevZoom_ != zoom) {\n          this.prevZoom_ = zoom;\n          this.resetViewport_(false);\n        }\n      }),\n      google.maps.event.addListener(this.getMap(), \"idle\", () => {\n        this.redraw_();\n      })\n    ];\n  }\n\n  /**\n   * Implementation of the onRemove interface method.\n   * Removes map event listeners and all cluster icons from the DOM.\n   * All managed markers are also put back on the map.\n   * @ignore\n   */\n  onRemove(): void {\n    // Put all the managed markers back on the map:\n    for (let i = 0; i < this.markers_.length; i++) {\n      if (this.markers_[i].getMap() !== this.activeMap_) {\n        this.markers_[i].setMap(this.activeMap_);\n      }\n    }\n\n    // Remove all clusters:\n    for (let i = 0; i < this.clusters_.length; i++) {\n      this.clusters_[i].remove();\n    }\n    this.clusters_ = [];\n\n    // Remove map event listeners:\n    for (let i = 0; i < this.listeners_.length; i++) {\n      google.maps.event.removeListener(this.listeners_[i]);\n    }\n    this.listeners_ = [];\n\n    this.activeMap_ = null;\n    this.ready_ = false;\n  }\n\n  /**\n   * Implementation of the draw interface method.\n   * @ignore\n   */\n  draw(): void {}\n\n  /**\n   * Sets up the styles object.\n   */\n  private setupStyles_(): void {\n    if (this.styles_.length > 0) {\n      return;\n    }\n\n    for (let i = 0; i < this.imageSizes_.length; i++) {\n      const size = this.imageSizes_[i];\n      this.styles_.push(\n        MarkerClusterer.withDefaultStyle({\n          url: this.imagePath_ + (i + 1) + \".\" + this.imageExtension_,\n          height: size,\n          width: size\n        })\n      );\n    }\n  }\n\n  /**\n   *  Fits the map to the bounds of the markers managed by the clusterer.\n   */\n  fitMapToMarkers(padding: number | google.maps.Padding): void {\n    const markers = this.getMarkers();\n    const bounds = new google.maps.LatLngBounds();\n    for (let i = 0; i < markers.length; i++) {\n      // March 3, 2018: Bug fix -- honor the ignoreHidden property\n      if (markers[i].getVisible() || !this.getIgnoreHidden()) {\n        bounds.extend(markers[i].getPosition());\n      }\n    }\n\n    (this.getMap() as google.maps.Map).fitBounds(bounds, padding);\n  }\n\n  /**\n   * Returns the value of the `gridSize` property.\n   *\n   * @return The grid size.\n   */\n  getGridSize(): number {\n    return this.gridSize_;\n  }\n\n  /**\n   * Sets the value of the `gridSize` property.\n   *\n   * @param gridSize The grid size.\n   */\n  setGridSize(gridSize: number): void {\n    this.gridSize_ = gridSize;\n  }\n\n  /**\n   * Returns the value of the `minimumClusterSize` property.\n   *\n   * @return The minimum cluster size.\n   */\n  getMinimumClusterSize(): number {\n    return this.minClusterSize_;\n  }\n\n  /**\n   * Sets the value of the `minimumClusterSize` property.\n   *\n   * @param minimumClusterSize The minimum cluster size.\n   */\n  setMinimumClusterSize(minimumClusterSize: number): void {\n    this.minClusterSize_ = minimumClusterSize;\n  }\n\n  /**\n   *  Returns the value of the `maxZoom` property.\n   *\n   *  @return The maximum zoom level.\n   */\n  getMaxZoom(): number {\n    return this.maxZoom_;\n  }\n\n  /**\n   *  Sets the value of the `maxZoom` property.\n   *\n   *  @param maxZoom The maximum zoom level.\n   */\n  setMaxZoom(maxZoom: number): void {\n    this.maxZoom_ = maxZoom;\n  }\n\n  getZIndex(): number {\n    return this.zIndex_;\n  }\n\n  setZIndex(zIndex: number): void {\n    this.zIndex_ = zIndex;\n  }\n\n  /**\n   *  Returns the value of the `styles` property.\n   *\n   *  @return The array of styles defining the cluster markers to be used.\n   */\n  getStyles(): ClusterIconStyle[] {\n    return this.styles_;\n  }\n\n  /**\n   *  Sets the value of the `styles` property.\n   *\n   *  @param styles The array of styles to use.\n   */\n  setStyles(styles: ClusterIconStyle[]): void {\n    this.styles_ = styles;\n  }\n\n  /**\n   * Returns the value of the `title` property.\n   *\n   * @return The content of the title text.\n   */\n  getTitle(): string {\n    return this.title_;\n  }\n\n  /**\n   *  Sets the value of the `title` property.\n   *\n   *  @param title The value of the title property.\n   */\n  setTitle(title: string): void {\n    this.title_ = title;\n  }\n\n  /**\n   * Returns the value of the `zoomOnClick` property.\n   *\n   * @return True if zoomOnClick property is set.\n   */\n  getZoomOnClick(): boolean {\n    return this.zoomOnClick_;\n  }\n\n  /**\n   *  Sets the value of the `zoomOnClick` property.\n   *\n   *  @param zoomOnClick The value of the zoomOnClick property.\n   */\n  setZoomOnClick(zoomOnClick: boolean): void {\n    this.zoomOnClick_ = zoomOnClick;\n  }\n\n  /**\n   * Returns the value of the `averageCenter` property.\n   *\n   * @return True if averageCenter property is set.\n   */\n  getAverageCenter(): boolean {\n    return this.averageCenter_;\n  }\n\n  /**\n   *  Sets the value of the `averageCenter` property.\n   *\n   *  @param averageCenter The value of the averageCenter property.\n   */\n  setAverageCenter(averageCenter: boolean): void {\n    this.averageCenter_ = averageCenter;\n  }\n\n  /**\n   * Returns the value of the `ignoreHidden` property.\n   *\n   * @return True if ignoreHidden property is set.\n   */\n  getIgnoreHidden(): boolean {\n    return this.ignoreHidden_;\n  }\n\n  /**\n   *  Sets the value of the `ignoreHidden` property.\n   *\n   *  @param ignoreHidden The value of the ignoreHidden property.\n   */\n  setIgnoreHidden(ignoreHidden: boolean): void {\n    this.ignoreHidden_ = ignoreHidden;\n  }\n\n  /**\n   * Returns the value of the `enableRetinaIcons` property.\n   *\n   * @return True if enableRetinaIcons property is set.\n   */\n  getEnableRetinaIcons(): boolean {\n    return this.enableRetinaIcons_;\n  }\n\n  /**\n   *  Sets the value of the `enableRetinaIcons` property.\n   *\n   *  @param enableRetinaIcons The value of the enableRetinaIcons property.\n   */\n  setEnableRetinaIcons(enableRetinaIcons: boolean): void {\n    this.enableRetinaIcons_ = enableRetinaIcons;\n  }\n\n  /**\n   * Returns the value of the `imageExtension` property.\n   *\n   * @return The value of the imageExtension property.\n   */\n  getImageExtension(): string {\n    return this.imageExtension_;\n  }\n\n  /**\n   *  Sets the value of the `imageExtension` property.\n   *\n   *  @param imageExtension The value of the imageExtension property.\n   */\n  setImageExtension(imageExtension: string): void {\n    this.imageExtension_ = imageExtension;\n  }\n\n  /**\n   * Returns the value of the `imagePath` property.\n   *\n   * @return The value of the imagePath property.\n   */\n  getImagePath(): string {\n    return this.imagePath_;\n  }\n\n  /**\n   *  Sets the value of the `imagePath` property.\n   *\n   *  @param imagePath The value of the imagePath property.\n   */\n  setImagePath(imagePath: string): void {\n    this.imagePath_ = imagePath;\n  }\n\n  /**\n   * Returns the value of the `imageSizes` property.\n   *\n   * @return The value of the imageSizes property.\n   */\n  getImageSizes(): number[] {\n    return this.imageSizes_;\n  }\n\n  /**\n   *  Sets the value of the `imageSizes` property.\n   *\n   *  @param imageSizes The value of the imageSizes property.\n   */\n  setImageSizes(imageSizes: number[]): void {\n    this.imageSizes_ = imageSizes;\n  }\n\n  /**\n   * Returns the value of the `calculator` property.\n   *\n   * @return the value of the calculator property.\n   */\n  getCalculator(): Calculator {\n    return this.calculator_;\n  }\n\n  /**\n   * Sets the value of the `calculator` property.\n   *\n   * @param calculator The value of the calculator property.\n   */\n  setCalculator(calculator: Calculator): void {\n    this.calculator_ = calculator;\n  }\n\n  /**\n   * Returns the value of the `batchSizeIE` property.\n   *\n   * @return the value of the batchSizeIE property.\n   */\n  getBatchSizeIE(): number {\n    return this.batchSizeIE_;\n  }\n\n  /**\n   * Sets the value of the `batchSizeIE` property.\n   *\n   *  @param batchSizeIE The value of the batchSizeIE property.\n   */\n  setBatchSizeIE(batchSizeIE: number): void {\n    this.batchSizeIE_ = batchSizeIE;\n  }\n\n  /**\n   * Returns the value of the `clusterClass` property.\n   *\n   * @return the value of the clusterClass property.\n   */\n  getClusterClass(): string {\n    return this.clusterClass_;\n  }\n\n  /**\n   * Sets the value of the `clusterClass` property.\n   *\n   *  @param clusterClass The value of the clusterClass property.\n   */\n  setClusterClass(clusterClass: string): void {\n    this.clusterClass_ = clusterClass;\n  }\n\n  /**\n   *  Returns the array of markers managed by the clusterer.\n   *\n   *  @return The array of markers managed by the clusterer.\n   */\n  getMarkers(): google.maps.Marker[] {\n    return this.markers_;\n  }\n\n  /**\n   *  Returns the number of markers managed by the clusterer.\n   *\n   *  @return The number of markers.\n   */\n  getTotalMarkers(): number {\n    return this.markers_.length;\n  }\n\n  /**\n   * Returns the current array of clusters formed by the clusterer.\n   *\n   * @return The array of clusters formed by the clusterer.\n   */\n  getClusters(): Cluster[] {\n    return this.clusters_;\n  }\n\n  /**\n   * Returns the number of clusters formed by the clusterer.\n   *\n   * @return The number of clusters formed by the clusterer.\n   */\n  getTotalClusters(): number {\n    return this.clusters_.length;\n  }\n\n  /**\n   * Adds a marker to the clusterer. The clusters are redrawn unless\n   *  `nodraw` is set to `true`.\n   *\n   * @param marker The marker to add.\n   * @param nodraw Set to `true` to prevent redrawing.\n   */\n  addMarker(marker: google.maps.Marker, nodraw?: boolean): void {\n    this.pushMarkerTo_(marker);\n    if (!nodraw) {\n      this.redraw_();\n    }\n  }\n\n  /**\n   * Adds an array of markers to the clusterer. The clusters are redrawn unless\n   *  `nodraw` is set to `true`.\n   *\n   * @param markers The markers to add.\n   * @param nodraw Set to `true` to prevent redrawing.\n   */\n  addMarkers(markers: google.maps.Marker[], nodraw?: boolean): void {\n    for (const key in markers) {\n      if (Object.prototype.hasOwnProperty.call(markers, key)) {\n        this.pushMarkerTo_(markers[key]);\n      }\n    }\n    if (!nodraw) {\n      this.redraw_();\n    }\n  }\n\n  /**\n   * Pushes a marker to the clusterer.\n   *\n   * @param marker The marker to add.\n   */\n  private pushMarkerTo_(\n    marker: google.maps.Marker & { isAdded?: boolean }\n  ): void {\n    // If the marker is draggable add a listener so we can update the clusters on the dragend:\n    if (marker.getDraggable()) {\n      google.maps.event.addListener(marker, \"dragend\", () => {\n        if (this.ready_) {\n          marker.isAdded = false;\n          this.repaint();\n        }\n      });\n    }\n    marker.isAdded = false;\n    this.markers_.push(marker);\n  }\n\n  /**\n   * Removes a marker from the cluster.  The clusters are redrawn unless\n   *  `nodraw` is set to `true`. Returns `true` if the\n   *  marker was removed from the clusterer.\n   *\n   * @param marker The marker to remove.\n   * @param nodraw Set to `true` to prevent redrawing.\n   * @return True if the marker was removed from the clusterer.\n   */\n  removeMarker(marker: google.maps.Marker, nodraw?: boolean): boolean {\n    const removed = this.removeMarker_(marker);\n\n    if (!nodraw && removed) {\n      this.repaint();\n    }\n\n    return removed;\n  }\n\n  /**\n   * Removes an array of markers from the cluster. The clusters are redrawn unless\n   *  `nodraw` is set to `true`. Returns `true` if markers were removed from the clusterer.\n   *\n   * @param markers The markers to remove.\n   * @param nodraw Set to `true` to prevent redrawing.\n   * @return True if markers were removed from the clusterer.\n   */\n  removeMarkers(markers: google.maps.Marker[], nodraw?: boolean): boolean {\n    let removed = false;\n\n    for (let i = 0; i < markers.length; i++) {\n      const r = this.removeMarker_(markers[i]);\n      removed = removed || r;\n    }\n\n    if (!nodraw && removed) {\n      this.repaint();\n    }\n\n    return removed;\n  }\n\n  /**\n   * Removes a marker and returns true if removed, false if not.\n   *\n   * @param marker The marker to remove\n   * @return Whether the marker was removed or not\n   */\n  private removeMarker_(marker: google.maps.Marker): boolean {\n    let index = -1;\n    if (this.markers_.indexOf) {\n      index = this.markers_.indexOf(marker);\n    } else {\n      for (let i = 0; i < this.markers_.length; i++) {\n        if (marker === this.markers_[i]) {\n          index = i;\n          break;\n        }\n      }\n    }\n\n    if (index === -1) {\n      // Marker is not in our list of markers, so do nothing:\n      return false;\n    }\n\n    marker.setMap(null);\n    this.markers_.splice(index, 1); // Remove the marker from the list of managed markers\n    return true;\n  }\n\n  /**\n   * Removes all clusters and markers from the map and also removes all markers\n   *  managed by the clusterer.\n   */\n  clearMarkers(): void {\n    this.resetViewport_(true);\n    this.markers_ = [];\n  }\n\n  /**\n   * Recalculates and redraws all the marker clusters from scratch.\n   *  Call this after changing any properties.\n   */\n  repaint(): void {\n    const oldClusters = this.clusters_.slice();\n    this.clusters_ = [];\n    this.resetViewport_(false);\n    this.redraw_();\n\n    // Remove the old clusters.\n    // Do it in a timeout to prevent blinking effect.\n    setTimeout(function() {\n      for (let i = 0; i < oldClusters.length; i++) {\n        oldClusters[i].remove();\n      }\n    }, 0);\n  }\n\n  /**\n   * Returns the current bounds extended by the grid size.\n   *\n   * @param bounds The bounds to extend.\n   * @return The extended bounds.\n   * @ignore\n   */\n  getExtendedBounds(\n    bounds: google.maps.LatLngBounds\n  ): google.maps.LatLngBounds {\n    const projection = this.getProjection();\n\n    // Turn the bounds into latlng.\n    const tr = new google.maps.LatLng(\n      bounds.getNorthEast().lat(),\n      bounds.getNorthEast().lng()\n    );\n    const bl = new google.maps.LatLng(\n      bounds.getSouthWest().lat(),\n      bounds.getSouthWest().lng()\n    );\n\n    // Convert the points to pixels and the extend out by the grid size.\n    const trPix = projection.fromLatLngToDivPixel(tr);\n    trPix.x += this.gridSize_;\n    trPix.y -= this.gridSize_;\n\n    const blPix = projection.fromLatLngToDivPixel(bl);\n    blPix.x -= this.gridSize_;\n    blPix.y += this.gridSize_;\n\n    // Convert the pixel points back to LatLng\n    const ne = projection.fromDivPixelToLatLng(trPix);\n    const sw = projection.fromDivPixelToLatLng(blPix);\n\n    // Extend the bounds to contain the new bounds.\n    bounds.extend(ne);\n    bounds.extend(sw);\n\n    return bounds;\n  }\n\n  /**\n   * Redraws all the clusters.\n   */\n  private redraw_(): void {\n    this.createClusters_(0);\n  }\n\n  /**\n   * Removes all clusters from the map. The markers are also removed from the map\n   *  if `hide` is set to `true`.\n   *\n   * @param hide Set to `true` to also remove the markers from the map.\n   */\n  private resetViewport_(hide?: boolean): void {\n    // Remove all the clusters\n    for (let i = 0; i < this.clusters_.length; i++) {\n      this.clusters_[i].remove();\n    }\n    this.clusters_ = [];\n\n    // Reset the markers to not be added and to be removed from the map.\n    for (let i = 0; i < this.markers_.length; i++) {\n      const marker = this.markers_[i];\n      marker.isAdded = false;\n      if (hide) {\n        marker.setMap(null);\n      }\n    }\n  }\n\n  /**\n   * Calculates the distance between two latlng locations in km.\n   *\n   * @param p1 The first lat lng point.\n   * @param p2 The second lat lng point.\n   * @return The distance between the two points in km.\n   * @link http://www.movable-type.co.uk/scripts/latlong.html\n   */\n  private distanceBetweenPoints_(\n    p1: google.maps.LatLng,\n    p2: google.maps.LatLng\n  ): number {\n    const R = 6371; // Radius of the Earth in km\n    const dLat = ((p2.lat() - p1.lat()) * Math.PI) / 180;\n    const dLon = ((p2.lng() - p1.lng()) * Math.PI) / 180;\n    const a =\n      Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n      Math.cos((p1.lat() * Math.PI) / 180) *\n        Math.cos((p2.lat() * Math.PI) / 180) *\n        Math.sin(dLon / 2) *\n        Math.sin(dLon / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    return R * c;\n  }\n\n  /**\n   * Determines if a marker is contained in a bounds.\n   *\n   * @param marker The marker to check.\n   * @param bounds The bounds to check against.\n   * @return True if the marker is in the bounds.\n   */\n  private isMarkerInBounds_(\n    marker: google.maps.Marker,\n    bounds: google.maps.LatLngBounds\n  ): boolean {\n    return bounds.contains(marker.getPosition());\n  }\n\n  /**\n   * Adds a marker to a cluster, or creates a new cluster.\n   *\n   * @param marker The marker to add.\n   */\n  private addToClosestCluster_(marker: google.maps.Marker): void {\n    let distance = 40000; // Some large number\n    let clusterToAddTo = null;\n    for (let i = 0; i < this.clusters_.length; i++) {\n      const cluster = this.clusters_[i];\n      const center = cluster.getCenter();\n      if (center) {\n        const d = this.distanceBetweenPoints_(center, marker.getPosition());\n        if (d < distance) {\n          distance = d;\n          clusterToAddTo = cluster;\n        }\n      }\n    }\n\n    if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {\n      clusterToAddTo.addMarker(marker);\n    } else {\n      const cluster = new Cluster(this);\n      cluster.addMarker(marker);\n      this.clusters_.push(cluster);\n    }\n  }\n\n  /**\n   * Creates the clusters. This is done in batches to avoid timeout errors\n   *  in some browsers when there is a huge number of markers.\n   *\n   * @param iFirst The index of the first marker in the batch of\n   *  markers to be added to clusters.\n   */\n  private createClusters_(iFirst: number): void {\n    if (!this.ready_) {\n      return;\n    }\n\n    // Cancel previous batch processing if we're working on the first batch:\n    if (iFirst === 0) {\n      google.maps.event.trigger(this, \"clusteringbegin\", this);\n\n      if (typeof this.timerRefStatic !== \"undefined\") {\n        clearTimeout(this.timerRefStatic);\n        delete this.timerRefStatic;\n      }\n    }\n\n    // Get our current map view bounds.\n    // Create a new bounds object so we don't affect the map.\n    //\n    // See Comments 9 & 11 on Issue 3651 relating to this workaround for a Google Maps bug:\n    let mapBounds: google.maps.LatLngBounds;\n\n    if (this.getMap().getZoom() > 3) {\n      mapBounds = new google.maps.LatLngBounds(\n        (this.getMap() as google.maps.Map).getBounds().getSouthWest(),\n        (this.getMap() as google.maps.Map).getBounds().getNorthEast()\n      );\n    } else {\n      mapBounds = new google.maps.LatLngBounds(\n        new google.maps.LatLng(85.02070771743472, -178.48388434375),\n        new google.maps.LatLng(-85.08136444384544, 178.00048865625)\n      );\n    }\n    const bounds = this.getExtendedBounds(mapBounds);\n\n    const iLast = Math.min(iFirst + this.batchSize_, this.markers_.length);\n\n    for (let i = iFirst; i < iLast; i++) {\n      const marker = this.markers_[i];\n      if (!marker.isAdded && this.isMarkerInBounds_(marker, bounds)) {\n        if (\n          !this.ignoreHidden_ ||\n          (this.ignoreHidden_ && marker.getVisible())\n        ) {\n          this.addToClosestCluster_(marker);\n        }\n      }\n    }\n\n    if (iLast < this.markers_.length) {\n      this.timerRefStatic = window.setTimeout(() => {\n        this.createClusters_(iLast);\n      }, 0);\n    } else {\n      delete this.timerRefStatic;\n      google.maps.event.trigger(this, \"clusteringend\", this);\n\n      for (let i = 0; i < this.clusters_.length; i++) {\n        this.clusters_[i].updateIcon();\n      }\n    }\n  }\n\n  /**\n   * The default function for determining the label text and style\n   * for a cluster icon.\n   *\n   * @param markers The array of markers represented by the cluster.\n   * @param numStyles The number of marker styles available.\n   * @return The information resource for the cluster.\n   */\n  static CALCULATOR(\n    markers: google.maps.Marker[],\n    numStyles: number\n  ): ClusterIconInfo {\n    let index = 0;\n    const count: number = markers.length;\n\n    let dv = count;\n    while (dv !== 0) {\n      dv = Math.floor(dv / 10);\n      index++;\n    }\n\n    index = Math.min(index, numStyles);\n    return {\n      text: count.toString(),\n      index: index,\n      title: \"\"\n    };\n  }\n\n  /**\n   * Generates default styles augmented with user passed values.\n   * Useful when you want to override some default values but keep untouched\n   *\n   * @param overrides override default values\n   */\n  static withDefaultStyle(overrides: ClusterIconStyle): ClusterIconStyle {\n    return {\n      textColor: \"black\",\n      textSize: 11,\n      textDecoration: \"none\",\n      textLineHeight: overrides.height,\n      fontWeight: \"bold\",\n      fontStyle: \"normal\",\n      fontFamily: \"Arial,sans-serif\",\n      backgroundPosition: \"0 0\",\n      ...overrides\n    };\n  }\n}\n", "/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { MarkerClusterer } from \"./markerclusterer\";\n\nexport { ClusterIconInfo, ClusterIconStyle } from \"./cluster-icon\";\nexport { MarkerClustererOptions } from \"./markerclusterer\";\n\nexport default MarkerClusterer;\n"],
  "mappings": "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",
  "names": []
}
